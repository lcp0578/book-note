## 第3章 模块化
#### 3.1 引言
- 库不过就是一些“我们碰巧用到的其他代码”，它也是用我们所使用的语言设施所编写的。
- 一个实体（例如，函数）可以有很多声明，但只能有一个定义。
#### 3.2 分离编译
- C++支持一种名为分离编译的概念，用户代码只能看见所用类型和函数的声明。有两种方法实现它：
	- 头文件：将声明放进独立的文件，该文件叫作头文件，然后将头文件以文本方式`#include`到代码中你需要声明的地方。
	- 模块（C++20新特性）：定义`module`文件，独立地编译它们，然后在需要时`import`它们。在`import`对应`module`时，只有其中显式`export`的声明是可见的。
- 头文件与模块的区别并不仅仅是在语法上
	- 模块只被编译一次，不会在每个用到它的翻译单元那里都被重新编译。
	- 两个模块`import`的顺序不影响其含义。
	- 如果你在模块内部`import`或者`#include`其他内容，模块的使用者不会隐式地获得那些模块的访问权：这意味着`import`没有传染性。
- 使用`module`时，不需要为了在接口文件内隐藏实现细节而将代码变得复杂；因为模块只导出显式`export`的声明。
#### 3.3 命名空间
- C++提供了一种称为**命名空间**的机制，一方面表达某些声明是属于一个整体的，另一方面表明它们的名字不会与其他命名空间中的名字冲突。
- `using`声明将名称从命名空间复制到当前作用域，就像在当前作用域中声明该名词一样。
	- 使用`using`指令时，我们失去了对所指定的命名空间名称的选择权，因此要谨慎使用。
#### 3.4 函数参数与返回值
- 首先要考虑的是，函数获取值的方法。默认情况使用复制（传值），如果希望直接指向调用者环境中的对象，我们使用引用（传引用）的方式。
- 从性能方面考虑，我们通常对小数据传值、对大数据传引用。
	- 这里的“小”意味着“复制开销很低”。
	- 它的准确定义取决于具体的机器架构，通常而言，“尺寸在两到三个指针以内”是一个不错的标准。但如果传递方式对性能影响非常显著，请先测量再做决定。
#### 3.5 建议
- 优先选择传`const`引用方式而非传普通引用方式。
- 不要过度使用结构化绑定；使用命名的返回类型通常可以使代码更为清晰。
