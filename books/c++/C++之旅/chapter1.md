## 第1章 基础
#### 1.1 引言
#### 1.2 程序
- ISO C++标准定义了两种实体
	- 核心语言特性，比如内置类型（例如，`char`与`int`）及循环（例如，for语句与while语句）
	- 标准库组件，比如容器（例如，`vector`与`map`）及输入输出操作（例如，`<<`与`getline()`）
- 指令import是C++ 20的新特性。
#### 1.3 函数
- 在编程过程中，可以使用相同的函数名定义多个函数，这被称为**函数重载**，是泛型编程的基本特性之一。
#### 1.4 类型、变量与运算
- 每种基础类型都与硬件设施直接对应，硬件决定了基础类型的固定尺寸，即可存储值的范围。
- 为了提升长字面量的可读性，可以使用单引号（`'`）作为数字分隔符。
- 初始化
	- 使用`=`的形式是C语言传统的方式，如果拿不定主意该用什么，就使用更通用的`{}`列表形式。抛开其他因素不谈，这种形式可以避免隐式类型转换导致的信息丢失。
	- 当没有明显的理由需要显式地指定类型时，一般使用`auto`。
#### 1.5 作用域和声明周期
- 声明语句把一个名字引入作用域：
	- 局部作用域：在函数或者匿名函数中定义的名字叫**局部名字**。
		- 它的作用域从声明它的地方开始，到声明语句所在的块结尾为止。
		- 语句块的边界由一对`{}`决定。
		- 函数参数的名字也属于局部名字。
	- 类作用域：如果一个名字被定义在类的内部，并且不再任何函数、匿名函数或`enum class`中，那么它可以被叫作**成员名字**（或类成员名字）
		- 它的作用域从它扩起声明的左花括号`{`开始，到对应的右花括号`}`结束。
	- 命名空间作用域：如果一个名字在命名空间的内部，并且不在任何函数、匿名函数或`enum class`中，则把这个名字称为**命名空间成员名字**。
		- 它的作用域从声明它的地方开始，到命名空间结束为止。
- 声明在所有结构之外的名字称为**全局名字**，我们说它位于**全局命名空间**。
#### 1.6 常量
- C++支持两种不变性
	- `const`:大致意味着“我承诺不修改这个值”。
		- 这主要用来说明接口，因此可以用指针或者引用的方式传入函数参数而不用担心被改变。
		- 编译器负责强制执行`const`承诺。
		- `const`声明的值可以在运行时被计算。
	- `constexpr`:大致意味着“请在编译时计算出它的值”。
		- 这主要用于声明常量，作用是把数据置于只读内存区域（更小概率被破坏），以提高性能。
		- `constexpr`的值必须由编译器计算。
#### 1.7 指针、数组和引用
- 当确实没有对象可指向，或者（比如在链表末端）希望表达出一种“没有可用对象”的含义时，我们可令指针取值为空指针`nullptr`。所有指针类型共享同一个`nullptr`。
- 指针可以为空，但引用不能，引用必须指向有效的对象（编译器也假定如此）
#### 1.8 检验
#### 1.9 映射到硬件
- C++的实现可以直接把机器的内存当做一个序列内存地址，并且直接将（有类型的）对象放进这些地址，同时使用指针取得对应的地址。
- 指针和引用都指向或引用一个对象，在内存中也都表示为一个机器地址。但是，使用它们的语言规则有点不同。给引用赋值不会改变引用指向的对象，而是改变所引用对象的值。
#### 1.10 建议
- 如果一个函数可能需要在编译时求值，那么将它声明为`constexpr`。
- 如果一个函数必须在编译时求值，那么将它声明为`consteval`。
