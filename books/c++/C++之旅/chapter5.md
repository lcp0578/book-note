## 第5章 类
#### 5.1 引言
#### 5.2 具体类型
- 具体类的基本思想是它们的行为“就像内置类型一样”。
- 定义在类内部的函数默认是内联的，也可以在函数声明前加上关键字`inline`，从而把它显式指定成内联的。
- 默认情况下，拷贝赋值函数及拷贝初始化函数会被隐式生成。
- 不需要实参就可以调用的构造函数称为**默认构造函数**。通过定义默认构造函数，可以有效防止该类型的对象未被初始化。
- `const`成员函数可以被`const`及非`const`对象调用，但非`const`成员函数只能被非`const`对象调用。
- 在使用用户自定义操作符（重载的操作符）时，我们应该小心谨慎，并且尊重其常规的使用习惯。
- 在构造函数中获取资源，然后在析构函数中释放它们，这种技术成为**资源获取即初始化**，又叫RAII。
#### 5.3 抽象类型
- 含有纯虚函数的类被称为抽象类。
- 我们把一个常用来为其他类型提供接口的类称为多态类型。
- 使用`override`指令是可选的，但显式指定允许编译器捕捉错误，比如在写虚函数名称时的书写错误或者类型声明错误。
- 显式指定`override`在大型的类层次结构中特别有用，否则我们很难知道谁试图覆盖谁。
#### 5.4 虚函数
- 常见的做法是编译器将虚函数的名字转换成函数指针表中对应的索引值，这张表就是所谓的**虚函数表**或简称为vtbl。
- 每个含有虚函数的类都有它自己的vtbl，用于辨识虚函数。
#### 5.5 类层次结构
- 类层次结构的益处主要体现在以下两个方面：
	- 接口继承：派生类的对象可以被用在任何需要基类对象的地方。也就是说，基类看起来像是派生类的接口。
	- 实现继承：基类负责提供可以简化派生类实现的函数或数据。
- 如果在运行时`dynamic_cast`的参数所指对象的类型与期望的类型或者期望类型的派生类不符，则`dynamic_cast`返回的结果是`nullptr`。
#### 5.6 建议
- 对性能要求比较高的组件，优先选择具体类而不是类层次结构。
- 如果成员函数不会改变对象的状态，则把它声明成`const`。
- 为了防止忘记用`delete`销毁用`new`创建的对象，建议使用`unique_ptr`或者`shared_ptr`。
