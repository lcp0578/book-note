##第1章 型别推导
#### 条款1：理解模板型别推导
- 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。
- 对万能引用形参进行推导时，左值实参会进行特殊处理。
- 对按值传递的形参进行推导时，若实参型别中带有const或volatile饰词，则它们还是会被当作不带const或volatile饰词类别来处理。
- 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。

#### 条款2：理解auto型别推导
- 在一般情况下，auto型别推导和模板型别推导时一模一样的，但是auto型别推导会假定用大括号括起来的初始化表达式代表一个`std:intializer_list`,但模板型别推导却不会。
- 在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。

#### 条款3：理解decltype
- C++11中，`decltype`的主要用途大概就在于声明那些返回值型别依赖于形参型别的函数模板。
- C++11允许对单表达式的lambda式的返回值型别实施推导，而C++14则将这个允许范围扩张到了一切lambda式和一切函数，包括那些多表达式的。
- 绝大多数情况下，`decltype`会得出变量或表达式的型别而不作任何修改。
- 对于型别为`T`的左值表达式，除非该表达式仅有一个名字，`decltype`总是得出型别`T&`。
- C++14支持`decltype(auto)`，和`auto`一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是`decltype`的规则。

#### 条款4：掌握查看型别推导结果的方法
- 想要让编译器显示其推导出的型别，一条有效的途径是使用该型别导致某些编译错误。而报告错误的消息几乎肯定会提及导致该错误的型别。
- 利用IDE编辑器、编译器错误消息和Boost.TypeIndex库常常能够查看到推导而得的型别。
- 有些工具产生的结果可能会无用，或者不准确。所以，理解C++型别推导规则是必要的。