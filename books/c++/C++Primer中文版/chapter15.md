## 第15章 面向对象程序设计
- 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时，将发生动态绑定。
- C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字`final`。
	
		class NoDerived final { /*  */ }
- 存在继承关系的类型之间的转换规则
	- 从派生类向基类的类型转换只对指针或引用类型有效。
	- 基类向派生类不存在隐式类型转换。
	- 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。
- 当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个一个。
- 如果我们使用`override`标记了某个函数，但该函数并没有覆盖已存在的虚函数。此时编译器将报错。
- 不能继承友元关系；每个类负责控制各自成员的访问权限。
- 如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。
