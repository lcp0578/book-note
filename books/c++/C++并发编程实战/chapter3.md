## 第3章 在线程间共享数据
- 在C++中，我们通过构造`std::mutex`的实例来创建互斥，调用成员函数`lock()`对其加锁，调用`unlock()`解锁。但不推荐直接调用成员函数的做法。原因是：若按此处理，那我们就必须记住，在函数以外的每条代码路径上都要调用`unlock()`，包括由于异常导致退出的路径。
- C++标准库提供了类模板`std::lock_guard<>`,针对互斥类融合实现了RAII手法：在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁。